{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Shana Library","text":"<p>Welcome to the documentation for Shana, a library developed in C language aimed at providing a vast set of generic data collections.</p> <p>Inspired by C++'s Standard Template Library (STL), the Shana project was created with the goal of offering a similar solution for C, enabling flexible and efficient management of elements of any type. Currently, Shana includes robust implementations for stacks and vectors (dynamic arrays).</p> <p>In the near future, we plan to integrate other collection types to further enrich this library and address a wider range of needs in C development.</p>"},{"location":"index.html#key-current-features","title":"Key Current Features","text":"<p>The current collections (stack, vector) offer the following characteristics :</p> <ul> <li>Genericity : Ability to store elements of any type (integers, floats, custom structures, etc.).</li> <li>Dynamic Memory Allocation : Flexibility in size, allowing collections to grow or shrink as needed.</li> <li>Clear and Intuitive API : Well-defined functions for initialization, memory deallocation, adding, removing, and accessing elements.</li> </ul>"},{"location":"index.html#quick-start-guide","title":"Quick Start Guide","text":"<p>To start using the Shana library, simply include the header file for the desired collection (e.g., stack.h for stacks) : </p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;shana/stack.h&gt;\n\n// gcc -o test_stack.exe test_stack.c -lshana &amp; color\n\nint main(){\n\n    stack_t stack;\n\n    stack_init(&amp;stack, sizeof(int));\n\n    /*\n    // works\n    int values[] = {10, 20, 30};\n\n    for (int i = 0; i &lt; 3; ++i){\n        stack_push(&amp;stack, &amp;values[i]);\n    }\n    */\n\n    /*\n    // works\n    int tmp = 10;\n\n    stack_push(&amp;stack, &amp;tmp);\n\n    tmp = 20;\n    stack_push(&amp;stack, &amp;tmp);\n\n    tmp = 30;\n    stack_push(&amp;stack, &amp;tmp);\n    */\n\n    stack_push(&amp;stack, &amp;(int){10});\n\n    stack_push(&amp;stack, &amp;(int){20});\n\n    stack_push(&amp;stack, &amp;(int){30});\n\n    while (!stack_is_empty(&amp;stack)){\n        printf(\"Top = %d\\n\", *(int*)stack_top(&amp;stack));\n        stack_pop(&amp;stack);\n    }\n\n    stack_free(&amp;stack);\n\n    return 0;\n}\n</code></pre>"},{"location":"index.html#module","title":"Module","text":"<ul> <li>Stack</li> <li>Vector</li> </ul>"},{"location":"index.html#example","title":"Example","text":"<ul> <li>example stack</li> <li>example vector</li> </ul>"},{"location":"index.html#project-information","title":"Project Information","text":"<ul> <li>Library Creation Date: July 26, 2025</li> <li>Main Author: https://github.com/Tina-1300</li> <li>Contributors: https://tina-1300.github.io/contributor-shana.html</li> <li>GitHub Repository: https://github.com/Tina-1300/shana</li> </ul> <p>Warning</p> <p>This project is constantly evolving. Your support is invaluable! Feel free to give a star \u2b50 to the GitHub repository if you find Shana useful or promising.</p>"},{"location":"stack.html","title":"API - Stack","text":""},{"location":"stack.html#struct","title":"Struct","text":"<p><code>typedef struct stack_t</code></p> <p>Description : The <code>stack_t</code> struct is designed to represent a generic stack in C.</p> <p>Definition : </p> <pre><code>typedef struct {\n    void* data;           /* Pointer to the raw memory block allocated for the stack elements.  */\n    size_t size;          /* Current number of elements stored in the stack.                    */\n    size_t capacity;      /* Maximum capacity of the stack.                                     */\n    size_t element_size;  /* size of an element (e.g., int, struct, etc.).                      */\n} stack_t;\n</code></pre> <p>Champs : </p> Name Type Description data void* Pointer to the data table size size_t Number of items currently stored capacity size_t Maximum allocated capacity element_size size_t Size of an element <p></p>"},{"location":"stack.html#function","title":"Function","text":"<p><code>void stack_init(stack_t* s, size_t element_size)</code></p> <p>Description : Initializes a new instance of <code>stack_t</code>.</p> <p>Prototype : </p> <pre><code>void stack_init(stack_t* s, size_t element_size);\n</code></pre> <p>Settings : </p> Name Type Description s stack_t* Pointer to the stack_t struct to initialize. element_size size_t Size (in bytes) of the element types stored in the stack. <p>Return value : </p> <p>This function does not return any value.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n</code></pre> <p>Note</p> <ul> <li>Allocate memory for the stack, don't forget to free the stack memory via <code>stack_free()</code></li> </ul> <p></p> <p></p> <p><code>void stack_free(stack_t* s)</code></p> <p>Description : frees the memory allocated to the stack.</p> <p>Prototype : </p> <pre><code>void stack_free(stack_t* s);\n</code></pre> <p>Settings : </p> Name Type Description s stack_t* Pointer to the stack_t struct to be freed. <p>Return value : </p> <p>This function does not return any value.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nstack_free(&amp;my_stack);\n</code></pre> <p>Note</p> <p>After calling this function, the memory allocated to the stack <code>my_stack</code> is freed.</p> <p></p> <p></p> <p><code>bool stack_push(stack_t* s, const void* element)</code></p> <p>Description : Adds an element to the top of the stack. </p> <p>Prototype : </p> <pre><code>bool stack_push(stack_t* s, const void* element);\n</code></pre> <p>Settings : </p> Name Type Description s stack_t* Pointer to the stack_t struct to be freed. element const void* Constant void pointer to a value to be added to the stack. <p>Return value : </p> <p>Returns true if the operation was successful, false otherwise.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nstack_push(&amp;my_stack, &amp;(int){10});\n\nstack_push(&amp;my_stack, &amp;(int){9});\n\nstack_push(&amp;my_stack, &amp;(int){8});\n\nstack_push(&amp;my_stack, &amp;(int){7});\n\nstack_push(&amp;my_stack, &amp;(int){6});\n\nstack_free(&amp;my_stack);\n</code></pre> <p></p> <p></p> <p><code>bool stack_pop(stack_t* s)</code></p> <p>Description : Removes the top element from the stack.</p> <p>Prototype : </p> <pre><code>bool stack_pop(stack_t* s);\n</code></pre> <p>Settings : </p> Name Type Description s stack_t* Pointer to the stack_t struct to be freed. <p>Return value : </p> <p>Returns true if an element was successfully removed, false if the stack was empty.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nstack_push(&amp;my_stack, &amp;(int){10});\n\nstack_push(&amp;my_stack, &amp;(int){9});\n\nstack_push(&amp;my_stack, &amp;(int){8});\n\nstack_push(&amp;my_stack, &amp;(int){7});\n\nstack_push(&amp;my_stack, &amp;(int){6});\n\nstack_pop(&amp;my_stack)\n\nstack_free(&amp;my_stack);\n</code></pre> <p></p> <p></p> <p><code>void* stack_top(stack_t* s)</code></p> <p>Description : Accesses the top element of the stack.</p> <p>Prototype : </p> <pre><code>void* stack_top(stack_t* s);\n</code></pre> <p>Settings : </p> Name Type Description s stack_t* Pointer to the stack_t struct to be freed. <p>Return value : </p> <p>Returns a void pointer to the top element of the stack, or NULL if the stack is empty.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nstack_push(&amp;my_stack, &amp;(int){10});\n\nstack_push(&amp;my_stack, &amp;(int){9});\n\nstack_push(&amp;my_stack, &amp;(int){8});\n\nstack_push(&amp;my_stack, &amp;(int){7});\n\nstack_push(&amp;my_stack, &amp;(int){6});\n\nwhile (!stack_is_empty(&amp;my_stack)){\n\n    printf(\"Top = %d\\n\", *(int*)stack_top(&amp;my_stack));\n\n    stack_pop(&amp;my_stack);\n}\n\n\nstack_free(&amp;my_stack);\n</code></pre> <p></p> <p></p> <p><code>bool stack_is_empty(const stack_t* s)</code></p> <p>Description : Checks if the stack is empty.</p> <p>Prototype : </p> <pre><code>bool stack_is_empty(const stack_t* s);\n</code></pre> <p>Settings : </p> Name Type Description s const stack_t* Pointer to the stack_t struct to be freed. <p>Return value : </p> <p>Returns true if the stack is empty, false otherwise.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nif (stack_is_empty(&amp;my_stack) != false){\n    printf(\"the stack is empty\");\n}\n\nstack_push(&amp;my_stack, &amp;(int){10});\n\nstack_push(&amp;my_stack, &amp;(int){9});\n\nstack_push(&amp;my_stack, &amp;(int){8});\n\nstack_push(&amp;my_stack, &amp;(int){7});\n\nstack_push(&amp;my_stack, &amp;(int){6});\n\nif (stack_is_empty(&amp;my_stack) != true){\n    printf(\"the stack is not empty\");\n}\n\n\nstack_free(&amp;my_stack);\n</code></pre> <p></p> <p></p> <p><code>size_t stack_size(const stack_t* s)</code></p> <p>Description : Checks the current number of elements in the stack.</p> <p>Prototype : </p> <pre><code>size_t stack_size(const stack_t* s);\n</code></pre> <p>Settings : </p> Name Type Description s const stack_t* Pointer to the stack_t struct to be freed. <p>Return value : </p> <p>Returns the current number of elements in the stack.</p> <p>Example of use :</p> <pre><code>stack_t my_stack;\n\nstack_init(&amp;my_stack, sizeof(int));\n\nif (stack_is_empty(&amp;my_stack) != false){\n    printf(\"the stack is empty\");\n}\n\nstack_push(&amp;my_stack, &amp;(int){10});\n\nstack_push(&amp;my_stack, &amp;(int){9});\n\nstack_push(&amp;my_stack, &amp;(int){8});\n\nstack_push(&amp;my_stack, &amp;(int){7});\n\nstack_push(&amp;my_stack, &amp;(int){6});\n\nif (stack_is_empty(&amp;my_stack) != true){\n    printf(\"the stack is not empty\");\n\n    printf(\"there are %d elements currently stored in the stack\", stack_size(&amp;my_stack));\n}\n\n\nstack_free(&amp;my_stack);\n</code></pre> <p></p> <p></p>"},{"location":"vector.html","title":"API - Vector","text":""},{"location":"vector.html#struct","title":"Struct","text":"<p><code>typedef struct vector_t</code></p> <p>Description : Struct representing a generic vector capable of storing elements of any type.</p> <p>Definition : </p> <pre><code>typedef struct {\n    void* data;           /* raw table          */\n    size_t size;          /* number of elements */ \n    size_t capacity;      /* allocated capacity */\n    size_t element_size;  /* size of an element */\n} vector_t;\n</code></pre> <p>Champs : </p> Name Type Description data void* Pointer to the data table size size_t Number of items currently stored capacity size_t Maximum allocated capacity element_size size_t Size of an element <p></p>"},{"location":"vector.html#function","title":"Function","text":"<p><code>void vector_init(vector_t* vec, size_t element_size)</code></p> <p>Description : Initializes a new instance of <code>vector_t</code>.</p> <p>Prototype : </p> <pre><code>void vector_init(vector_t* vec, size_t element_size);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct to initialize. element_size size_t Size (in bytes) of the element types stored in the vector. <p>Return value : </p> <p>This function does not return any value.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n</code></pre> <p>Note</p> <ul> <li>After calling this function, the vector <code>my_vector</code> is ready to be used.</li> <li>The function allocates the memory needed to manage the vector.</li> <li>The memory of the vector <code>my_vector</code> will need to be freed at the end of its use via the function <code>vector_free(vector_t* vec)</code>.</li> </ul> <p></p> <p></p> <p><code>void vector_free(vector_t* vec)</code></p> <p>Description : frees the memory allocated to the vector.</p> <p>Prototype : </p> <pre><code>void vector_free(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct to be freed. <p>Return value : </p> <p>This function does not return any value.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_free(&amp;my_vector);\n</code></pre> <p>Note</p> <p>After calling this function, the memory allocated to the vector <code>my_vector</code> is freed.</p> <p></p> <p></p> <p><code>bool vector_push_back(vector_t* vec, const void* element)</code></p> <p>Description : This function adds a value to the end of the vector.</p> <p>Prototype : </p> <pre><code>bool vector_push_back(vector_t* vec, const void* element);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. element const void* Constant void pointer to the element to be inserted. <p>Return value : </p> <p>This function only returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>void* vector_at(vector_t* vec, size_t index)</code></p> <p>Description : This function retrieves the value stored at the specified index.</p> <p>Prototype : </p> <pre><code>void* vector_at(vector_t* vec, size_t index);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. index size_t Index of the item to be retrieved. <p>Return value : </p> <p>This function returns a void pointer to the element stored at the specified index.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\n\nint* val = (int*)vector_at(&amp;my_vector, 0);\nprintf(\"vec[0] = %d\\n\", *val);\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>void* vector_front(vector_t* vec)</code></p> <p>Description : This function allows you to retrieve the value stored at the first location of the vector.</p> <p>Prototype : </p> <pre><code>void* vector_front(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>This function returns a void pointer to the element stored at the first location of the vector.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nprintf(\"%d\", *(int*)vector_front(&amp;my_vector));\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>void * vector_back(vector_t* vec)</code></p> <p>Description : This function allows you to retrieve the value stored at the last location of the vector.</p> <p>Prototype : </p> <pre><code>void * vector_back(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>This function returns a void pointer to the element stored at the last location of the vector.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nprintf(\"%d\", *(int*)vector_back(&amp;my_vector));\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>size_t vector_size(const vector_t* vec)</code></p> <p>Description : This function retrieves the number of elements stored in the vector.</p> <p>Prototype : </p> <pre><code>size_t vector_size(const vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns the number of elements stored in the vector.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nfor (size_t i = 0; i &lt; vector_size(&amp;my_vector); ++i){\n    int* val = (int*)vector_at(&amp;my_vector, i);\n    printf(\"vec[%zu] = %d\\n\", i, *val);\n}\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>size_t vector_capacity(const vector_t* vec)</code></p> <p>Description : This function retrieves the allocated capacity.</p> <p>Prototype : </p> <pre><code>size_t vector_capacity(const vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns the memory capacity allocated to the vector.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nprintf(\"vector capacity : %d\", vector_capacity(&amp;my_vector));\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_is_empty(const vector_t* vec)</code></p> <p>Description : This function checks if the vector is empty.</p> <p>Prototype : </p> <pre><code>bool vector_is_empty(const vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec const vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns <code>true</code> if the vector is empty and <code>false</code> if the vector is not empty.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\nif (vector_is_empty(&amp;my_vector) == true){\n    printf(\"the vector is empty\");\n}\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nif (vector_is_empty(&amp;my_vector) == false){\n    printf(\"the vector is not empty\");\n}\n\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_pop_back(vector_t* vec)</code></p> <p>Description : This function removes the last element of the vector.</p> <p>Prototype : </p> <pre><code>bool vector_pop_back(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nif (vector_is_empty(&amp;my_vector) == false){\n    printf(\"the vector is not empty\");\n    if(vector_pop_back(&amp;my_vector) ==true){\n        printf(\"everything went well\")\n    }\n}\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_pop_front(vector_t* vec)</code></p> <p>Description : This function removes the first element from the vector.</p> <p>Prototype : </p> <pre><code>bool vector_pop_front(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nif (vector_is_empty(&amp;my_vector) == false){\n    printf(\"the vector is not empty\");\n    if(vector_pop_front(&amp;my_vector) == true){\n        printf(\"everything went well\")\n    }\n}\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_pop_at(vector_t* vec, size_t index)</code></p> <p>Description : This function removes an element at the specified index.</p> <p>Prototype : </p> <pre><code>bool vector_pop_at(vector_t* vec, size_t index);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. index size_t Index of the item to be deleted. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nif (vector_is_empty(&amp;my_vector) == false){\n    printf(\"the vector is not empty\");\n    if (vector_pop_at(&amp;my_vector, 1) == true){\n        printf(\"operation successfully completed\");\n    }\n}\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_push_front(vector_t* vec, const void* element)</code></p> <p>Description : This function adds an element to the front of the vector.</p> <p>Prototype : </p> <pre><code>bool vector_push_front(vector_t* vec, const void* element);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. element const void * Empty constant pointer to the element to be added. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\n\nvector_push_front(&amp;my_vector, &amp;(int){5});\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_push_at(vector_t* vec, size_t index, const void* element)</code></p> <p>Description : This function adds an element at a specified index of the vector.</p> <p>Prototype : </p> <pre><code>bool vector_push_at(vector_t* vec, size_t index, const void* element);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. index size_t Index to specify to add the element to the vector. element const void * Empty constant pointer to the element to be added. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\nvector_push_back(&amp;my_vector, &amp;(int){6});\n\n\nvector_push_at(&amp;my_vector, 1 , &amp;(int){5});\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_reverse(vector_t* vec)</code></p> <p>Description : This function reverses all elements of the vector, the first element becomes the last and so on.</p> <p>Prototype : </p> <pre><code>bool vector_reverse(vector_t* vec);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9});\nvector_push_back(&amp;my_vector, &amp;(int){3});\nvector_push_back(&amp;my_vector, &amp;(int){6});\n\n// display : 9, 3, 6\n\nvector_reverse(&amp;my_vector);\n\n// display : 6, 3, 9\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_swap(vector_t* vec, size_t index_element_a, size_t index_element_b)</code></p> <p>Description : This function swaps two elements in the vector.</p> <p>Prototype : </p> <pre><code>bool vector_swap(vector_t* vec, size_t index_element_a, size_t index_element_b);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. index_element_a size_t Index of the element to be exchanged with the second. index_element_b size_t Index of the element to be exchanged with the first. <p>Return value : </p> <p>Returns <code>true</code> if everything went well.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9}); // index : 0\n\nvector_push_back(&amp;my_vector, &amp;(int){3}); // index : 1\n\nvector_push_back(&amp;my_vector, &amp;(int){6}); // index : 2\n\nvector_push_back(&amp;my_vector, &amp;(int){2}); // index : 3\n\nvector_swap(&amp;my_vector, 2, 0);\n\n// display : 6, 3, 9, 2\n\n\nvector_free(&amp;my_vector);\n</code></pre> <p></p> <p></p> <p><code>bool vector_check(vector_t* vec, const void* element)</code></p> <p>Description : This function allows you to check if an element is already present in the vector.</p> <p>Prototype : </p> <pre><code>bool vector_check(vector_t* vec, const void* element);\n</code></pre> <p>Settings : </p> Name Type Description vec vector_t* Pointer to the vector_t struct. element const void* Empty constant pointer to the element to check. <p>Return value : </p> <p>This function returns true if the element is present and false if it is not present or if there was an error.</p> <p>Example of use :</p> <pre><code>vector_t my_vector;\n\nvector_init(&amp;my_vector, sizeof(int));\n\n\nvector_push_back(&amp;my_vector, &amp;(int){9}); // index : 0\n\nvector_push_back(&amp;my_vector, &amp;(int){3}); // index : 1\n\nvector_push_back(&amp;my_vector, &amp;(int){6}); // index : 2\n\nvector_push_back(&amp;my_vector, &amp;(int){2}); // index : 3\n\nvector_swap(&amp;my_vector, 2, 0); // display : 6, 3, 9, 2\n\n\nif (vector_check(&amp;my_vector, &amp;(int){3})){\n    printf(\"the element is present in the vector\");\n}\n\n\nvector_free(&amp;my_vector);\n</code></pre>"},{"location":"example/example_stack.html","title":"Example - Stack","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;shana/stack.h&gt;\n\n// gcc -o example_stack.exe example_stack.c -lshana &amp; color\n\nint main(){\n\n    stack_t stack;\n\n    stack_init(&amp;stack, sizeof(int));\n\n    /*\n    int values[] = {10, 20, 30};\n\n    for (int i = 0; i &lt; 3; ++i){\n        stack_push(&amp;stack, &amp;values[i]);\n    }\n    */\n\n    /*\n    int tmp = 10;\n\n    stack_push(&amp;stack, &amp;tmp);\n\n    tmp = 20;\n    stack_push(&amp;stack, &amp;tmp);\n\n    tmp = 30;\n    stack_push(&amp;stack, &amp;tmp);\n    */\n\n    stack_push(&amp;stack, &amp;(int){10});\n\n    stack_push(&amp;stack, &amp;(int){20});\n\n    stack_push(&amp;stack, &amp;(int){30});\n\n\n    while (!stack_is_empty(&amp;stack)){\n        printf(\"Top = %d\\n\", *(int*)stack_top(&amp;stack));\n        stack_pop(&amp;stack);\n    }\n\n    stack_free(&amp;stack);\n\n\n    return 0;\n}\n</code></pre>"},{"location":"example/example_vector.html","title":"Example - Vector","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;shana/vector.h&gt;\n\n// gcc -o example_vector.exe example_vector.c -lshana &amp; color\n\nvoid space(unsigned int count_space){\n    for (unsigned int i = 0; i != count_space; i++){\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n\n    vector_t vec;\n\n\n\n    vector_init(&amp;vec, sizeof(int));\n\n    for (int i = 0; i &lt; 10; ++i){\n        vector_push_back(&amp;vec, &amp;i);\n    }\n\n    vector_pop_back(&amp;vec); // there will be 8 left\n\n    for (size_t i = 0; i &lt; vector_size(&amp;vec); ++i){\n        int* val = (int*)vector_at(&amp;vec, i);\n        printf(\"vec[%zu] = %d\\n\", i, *val);\n    }\n\n\n    printf(\"%d\", *(int*)vector_front(&amp;vec));\n\n    space(1);\n\n    printf(\"%d\", *(int*)vector_back(&amp;vec));\n\n\n    space(1);\n\n    vector_free(&amp;vec);\n\n\n    return 0;\n};\n</code></pre>"}]}